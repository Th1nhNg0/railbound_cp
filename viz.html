<!DOCTYPE html>
<html>
  <head>
    <title>MiniZinc Visualisation</title>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <style>
      .grid-container {
        display: inline-grid;
        gap: 0;
        border: 2px solid black;
      }
      .grid-cell {
        width: 80px;
        height: 80px;
        border: 1px solid black;
        position: relative;
        box-sizing: border-box;
      }
      .grid-cell img {
        width: 100%;
        height: 100%;
        position: absolute;
        top: 0;
        left: 0;
        transform-origin: center center;
      }
      .bg-normal {
        background-color: #f0f0f0;
      }
      .bg-target {
        background-color: #90ee90;
      }
      .bg-init {
        background-color: #d0d0d0;
      }
      .bg-tunnel {
        background-color: #c0c0c0;
      }
      .gate-indicator {
        position: absolute;
        top: 5px;
        left: 5px;
        width: 24px;
        height: 24px;
        border-radius: 50%;
        border: 3px solid #000;
        z-index: 15;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        font-size: 12px;
        color: white;
        text-shadow: 1px 1px 2px black;
      }
      .gate-open {
        background-color: #00ff00;
      }
      .gate-closed {
        background-color: #ff0000;
      }
      .activation-indicator {
        position: absolute;
        bottom: 5px;
        right: 5px;
        width: 24px;
        height: 24px;
        background-color: #ffaa00;
        border: 2px solid #000;
        border-radius: 4px;
        z-index: 15;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        font-size: 12px;
        color: white;
        text-shadow: 1px 1px 2px black;
      }
      .dswitch-indicator {
        position: absolute;
        top: 5px;
        right: 5px;
        width: 24px;
        height: 24px;
        border-radius: 50%;
        border: 3px solid #9b63cb;
        background-color: #f5e2ff;
        z-index: 15;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        font-size: 12px;
        color: #9b63cb;
        text-shadow: 0px 0px 1px white;
      }
      .station-indicator {
        position: absolute;
        bottom: 5px;
        left: 5px;
        width: 24px;
        height: 24px;
        background-color: #00aaff;
        border: 2px solid #0066cc;
        border-radius: 4px;
        z-index: 15;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        font-size: 12px;
        color: white;
        text-shadow: 1px 1px 2px black;
      }
    </style>
  </head>
  <body>
    <main class="flex items-center justify-center min-h-screen">
      <div class="flex flex-col items-center gap-4 w-full max-w-5xl px-4">
        <div id="gridContainer"></div>
        <div
          id="timelineControls"
          class="w-full max-w-md mx-auto"
          style="display: none"
        >
          <label
            for="timeSlider"
            class="block text-center text-lg font-semibold mb-2"
          >
            Time step: <span id="timeLabel">0</span>
          </label>
          <input
            type="range"
            id="timeSlider"
            class="w-full"
            min="0"
            max="0"
            value="0"
          />
        </div>
      </div>
    </main>
    <script src="/minizinc-ide.js"></script>
    <script>
      (async function () {
        // getUserData can be used to retrieve the JSON data passed to vis_server()
        const userData = await MiniZincIDE.getUserData();
        const {
          grid_height,
          grid_width,
          init_positions,
          trains,
          decoys,
          target,
          tunnels,
          gates,
          activations,
          dswitches,
          stations,
        } = userData;

        const container = document.getElementById("gridContainer");
        const timelineControls = document.getElementById("timelineControls");
        const timeSlider = document.getElementById("timeSlider");
        const timeLabel = document.getElementById("timeLabel");

        const DIR_STRING_TO_NUM = { TOP: 1, RIGHT: 2, DOWN: 3, LEFT: 4 };
        const DIR_NUM_TO_STRING = { 1: "TOP", 2: "RIGHT", 3: "DOWN", 4: "LEFT" };
        const DSWITCH_TOGGLE_MAP = {
          DSWITCH_T_D_R: "DSWITCH_D_T_R",
          DSWITCH_T_D_L: "DSWITCH_D_T_L",
          DSWITCH_D_T_R: "DSWITCH_T_D_R",
          DSWITCH_D_T_L: "DSWITCH_T_D_L",
          DSWITCH_R_L_T: "DSWITCH_L_R_T",
          DSWITCH_R_L_D: "DSWITCH_L_R_D",
          DSWITCH_L_R_T: "DSWITCH_R_L_T",
          DSWITCH_L_R_D: "DSWITCH_R_L_D",
        };

        const ESWITCH_TOGGLE_MAP = {
          ESWITCH_T_D_R: "ESWITCH_D_T_R",
          ESWITCH_D_T_R: "ESWITCH_T_D_R",
          ESWITCH_T_D_L: "ESWITCH_D_T_L",
          ESWITCH_D_T_L: "ESWITCH_T_D_L",
          ESWITCH_R_L_T: "ESWITCH_L_R_T",
          ESWITCH_L_R_T: "ESWITCH_R_L_T",
          ESWITCH_R_L_D: "ESWITCH_L_R_D",
          ESWITCH_L_R_D: "ESWITCH_R_L_D",
        };

        const eswitches = (init_positions ?? [])
          .map((pos, index) => ({ ...pos, originalIndex: index }))
          .filter((pos) => pos[2].e.startsWith("ESWITCH"));

        function resolveDirectionValue(direction) {
          if (direction == null) {
            return null;
          }

          if (typeof direction === "object" && "e" in direction) {
            const value = direction.e;
            if (typeof value === "string") {
              return DIR_STRING_TO_NUM[value] ?? null;
            }
            if (typeof value === "number") {
              return DIR_NUM_TO_STRING[value] ? value : null;
            }
          }

          if (typeof direction === "string") {
            return DIR_STRING_TO_NUM[direction] ?? null;
          }

          if (typeof direction === "number") {
            return DIR_NUM_TO_STRING[direction] ? direction : null;
          }

          return null;
        }

        function directionFromDelta(from, to) {
          if (!from || !to) {
            return null;
          }

          const rowDelta = (to.row ?? 0) - (from.row ?? 0);
          const colDelta = (to.col ?? 0) - (from.col ?? 0);

          if (rowDelta === -1 && colDelta === 0) {
            return DIR_STRING_TO_NUM.TOP;
          }
          if (rowDelta === 1 && colDelta === 0) {
            return DIR_STRING_TO_NUM.DOWN;
          }
          if (rowDelta === 0 && colDelta === 1) {
            return DIR_STRING_TO_NUM.RIGHT;
          }
          if (rowDelta === 0 && colDelta === -1) {
            return DIR_STRING_TO_NUM.LEFT;
          }

          return null;
        }

        function determineStepDirections(pathPositions, initialDirection = null) {
          if (!Array.isArray(pathPositions) || pathPositions.length === 0) {
            return [];
          }

          const steps = [];
          let lastDirection = initialDirection ?? null;

          for (let i = 0; i < pathPositions.length; i++) {
            const current = pathPositions[i];
            const next = pathPositions[i + 1];
            const previous = pathPositions[i - 1];

            let direction = directionFromDelta(current, next);

            if (direction == null) {
              direction = directionFromDelta(previous, current);
            }

            if (direction == null) {
              direction = lastDirection;
            }

            if (direction == null) {
              direction = initialDirection;
            }

            if (direction != null) {
              lastDirection = direction;
            }

            steps.push({
              ...current,
              direction: lastDirection,
            });
          }

          return steps;
        }

        const initialTrainPositions = (trains ?? []).map((train, idx) => ({
          row: train?.[0],
          col: train?.[1],
          direction: resolveDirectionValue(train?.[2]),
          idx,
          isDecoy: false,
        }));

        const initialDecoyPositions = (decoys ?? []).map((decoy, idx) => ({
          row: decoy?.[0],
          col: decoy?.[1],
          direction: resolveDirectionValue(decoy?.[2]),
          idx,
          isDecoy: true,
        }));

        let currentGridData = null;
        let trainPaths = [];
        let decoyPaths = [];
        let gateOpenStates = [];
        let dswitchToggledStates = [];
        let eswitchToggledStates = [];
        let shouldToggle = [];
        let currentTimeStep = 0;
        let maxTimeStep = 0;
        let timeSliderInUpdate = false;

        function computeGateStates() {
          if (!gates || !shouldToggle) {
            gateOpenStates = [];
            return;
          }

          const computedStates = [];
          for (let g_idx = 0; g_idx < gates.length; g_idx++) {
            const gate = gates[g_idx];
            const [, , activation_id, initially_open] = gate;

            const gateStatesForT = [];
            gateStatesForT[0] = initially_open;

            for (let t = 1; t <= maxTimeStep; t++) {
              const toggle = shouldToggle[activation_id - 1]?.[t] ?? false;
              const previousState = gateStatesForT[t - 1];
              gateStatesForT[t] = toggle ? !previousState : previousState;
            }
            computedStates[g_idx] = gateStatesForT;
          }
          gateOpenStates = computedStates;
        }

        function computeDSwitchStates() {
          if (!dswitches || !shouldToggle) {
            dswitchToggledStates = [];
            return;
          }

          const computedStates = [];
          for (let ds_idx = 0; ds_idx < dswitches.length; ds_idx++) {
            const dswitch = dswitches[ds_idx];
            const [, , activation_id] = dswitch;

            const dswitchStatesForT = [];
            dswitchStatesForT[0] = false; // Initial state is not toggled

            for (let t = 1; t <= maxTimeStep; t++) {
              const toggle = shouldToggle[activation_id - 1]?.[t] ?? false;
              const previousState = dswitchStatesForT[t - 1];
              dswitchStatesForT[t] = toggle ? !previousState : previousState;
            }
            computedStates[ds_idx] = dswitchStatesForT;
          }
          dswitchToggledStates = computedStates;
        }

        function safeParseJSON(value, fallback) {
          if (typeof value !== "string") {
            return fallback;
          }

          try {
            return JSON.parse(value);
          } catch (error) {
            console.warn("Failed to parse JSON payload:", error);
            return fallback;
          }
        }

        // Generate different colors for each tunnel pair
        function getTunnelColor(tunnelIndex) {
          const colors = [
            "#00FF00", // Green (original)
            "#FF00FF", // Magenta
            "#00FFFF", // Cyan
            "#FFFF00", // Yellow
            "#FF8800", // Orange
            "#8800FF", // Purple
            "#FF0088", // Pink
            "#00FF88", // Teal
          ];
          return colors[tunnelIndex % colors.length];
        }

        // Load and cache tunnel SVG with color replacement
        let tunnelSvgTemplate = null;
        const tunnelSvgPromise = fetch("images/Tunnel.svg")
          .then((response) => response.text())
          .then((svgText) => {
            tunnelSvgTemplate = svgText;
            return svgText;
          });

        // Helper to get rotation angle from direction
        // Direction: TOP=1, RIGHT=2, DOWN=3, LEFT=4 (or string names)
        // Tunnels default to LEFT (0°), Cars default to RIGHT (0°)
        function getRotation(direction, isCarImage = false) {
          const dirNum = resolveDirectionValue(direction);

          if (isCarImage) {
            // Car images default to RIGHT
            const carRotationMap = {
              1: -90, // TOP: rotate -90° (or 270°)
              2: 0, // RIGHT: no rotation (default)
              3: 90, // DOWN: rotate 90°
              4: 180, // LEFT: rotate 180°
            };
            return carRotationMap[dirNum] || 0;
          } else {
            // Tunnel images default to LEFT
            const tunnelRotationMap = {
              1: 90, // TOP: rotate 90°
              2: 180, // RIGHT: rotate 180°
              3: 270, // DOWN: rotate 270°
              4: 0, // LEFT: no rotation (default)
            };
            return tunnelRotationMap[dirNum] || 0;
          }
        }

        // Draw grid
        function drawGrid(
          gridData = null,
          activeMovingObjects = [...initialTrainPositions, ...initialDecoyPositions]
        ) {
          container.innerHTML = "";
          container.style.gridTemplateColumns = `repeat(${grid_width}, 80px)`;
          container.style.gridTemplateRows = `repeat(${grid_height}, 80px)`;
          container.className = "grid-container";

          for (let row = 0; row < grid_height; row++) {
            for (let col = 0; col < grid_width; col++) {
              const cell = document.createElement("div");
              cell.className = "grid-cell";

              // Check cell type for background color
              const isTarget =
                target && target[0] === row + 1 && target[1] === col + 1;
              const isInitPos = init_positions?.some(
                ([r, c]) => r === row + 1 && c === col + 1
              );
              const isTunnel = tunnels?.some(
                ([r_A, c_A, , r_B, c_B]) =>
                  (r_A === row + 1 && c_A === col + 1) ||
                  (r_B === row + 1 && c_B === col + 1)
              );

              if (isTarget) {
                cell.classList.add("bg-target");
              } else if (isTunnel) {
                cell.classList.add("bg-tunnel");
              } else if (isInitPos) {
                cell.classList.add("bg-init");
              } else {
                cell.classList.add("bg-normal");
              }

              // Check if this cell has an init position piece
              const initPos = init_positions?.find(
                ([r, c]) => r === row + 1 && c === col + 1
              );

              // Check if this cell has a tunnel and get its index
              let tunnelIndex = -1;
              const tunnel = tunnels?.find((t, idx) => {
                const [r_A, c_A, , r_B, c_B] = t;
                if (
                  (r_A === row + 1 && c_A === col + 1) ||
                  (r_B === row + 1 && c_B === col + 1)
                ) {
                  tunnelIndex = idx;
                  return true;
                }
                return false;
              });

              // Add track piece if solution is provided
              if (gridData) {
                const piece = gridData[row][col];

                // Don't draw solution piece if this is an init position or tunnel
                // (keep the original piece visible)
                if (initPos) {
                  const [, , track] = initPos;
                  let pieceToDraw = track;

                  const dswitchIndex = dswitches?.findIndex(
                    ([r, c]) => r === row + 1 && c === col + 1
                  );
                  if (dswitchIndex !== -1) {
                    const isToggled =
                      dswitchToggledStates[dswitchIndex]?.[currentTimeStep] ??
                      false;
                    if (isToggled) {
                      const toggledPieceName =
                        DSWITCH_TOGGLE_MAP[pieceToDraw.e];
                      if (toggledPieceName) {
                        pieceToDraw = { e: toggledPieceName };
                      }
                    }
                  }

                  const eswitchIndex = eswitches?.findIndex(
                    (eswitch) => eswitch[0] === row + 1 && eswitch[1] === col + 1
                  );

                  if (eswitchIndex !== -1) {
                    const isToggled =
                      eswitchToggledStates[eswitchIndex]?.[currentTimeStep] ??
                      false;
                    if (isToggled) {
                      const toggledPieceName =
                        ESWITCH_TOGGLE_MAP[pieceToDraw.e];
                      if (toggledPieceName) {
                        pieceToDraw = { e: toggledPieceName };
                      }
                    }
                  }

                  const img = document.createElement("img");
                  img.src = `images/${pieceToDraw.e}.svg`;
                  img.alt = pieceToDraw.e;
                  cell.appendChild(img);
                } else if (tunnel) {
                  const [r_A, c_A, dir_A, r_B, c_B, dir_B] = tunnel;
                  const isTunnelA = r_A === row + 1 && c_A === col + 1;
                  const dir = isTunnelA ? dir_A : dir_B;
                  const color = getTunnelColor(tunnelIndex);

                  if (tunnelSvgTemplate) {
                    const coloredSvg = tunnelSvgTemplate.replace(
                      /#00FF00/g,
                      color
                    );
                    const svgBlob = new Blob([coloredSvg], {
                      type: "image/svg+xml",
                    });
                    const url = URL.createObjectURL(svgBlob);

                    const img = document.createElement("img");
                    img.src = url;
                    img.alt = "Tunnel";
                    img.style.transform = `rotate(${getRotation(
                      dir,
                      false
                    )}deg)`;
                    cell.appendChild(img);
                  } else {
                    // Fallback if SVG not loaded yet
                    const img = document.createElement("img");
                    img.src = "images/Tunnel.svg";
                    img.alt = "Tunnel";
                    img.style.transform = `rotate(${getRotation(
                      dir,
                      false
                    )}deg)`;
                    cell.appendChild(img);
                  }
                } else if (piece.e !== "EMPTY") {
                  // Only draw solution piece if not init or tunnel
                  let pieceToDraw = piece;
                  const dswitchIndex = dswitches?.findIndex(
                    ([r, c]) => r === row + 1 && c === col + 1
                  );
                  if (dswitchIndex !== -1) {
                    const isToggled =
                      dswitchToggledStates[dswitchIndex]?.[currentTimeStep] ??
                      false;
                    if (isToggled) {
                      const toggledPieceName =
                        DSWITCH_TOGGLE_MAP[pieceToDraw.e];
                      if (toggledPieceName) {
                        pieceToDraw = { e: toggledPieceName };
                      }
                    }
                  }
                  const img = document.createElement("img");
                  img.src = `images/${pieceToDraw.e}.svg`;
                  img.alt = pieceToDraw.e;
                  cell.appendChild(img);
                }
              } else {
                // Draw initial state
                if (initPos) {
                  const [, , track] = initPos;

                  const img = document.createElement("img");
                  img.src = `images/${track.e}.svg`;
                  img.alt = track.e;
                  cell.appendChild(img);
                }

                if (tunnel) {
                  const [r_A, c_A, dir_A, r_B, c_B, dir_B] = tunnel;
                  const isTunnelA = r_A === row + 1 && c_A === col + 1;
                  const dir = isTunnelA ? dir_A : dir_B;
                  const color = getTunnelColor(tunnelIndex);

                  if (tunnelSvgTemplate) {
                    const coloredSvg = tunnelSvgTemplate.replace(
                      /#00FF00/g,
                      color
                    );
                    const svgBlob = new Blob([coloredSvg], {
                      type: "image/svg+xml",
                    });
                    const url = URL.createObjectURL(svgBlob);

                    const img = document.createElement("img");
                    img.src = url;
                    img.alt = "Tunnel";
                    img.style.transform = `rotate(${getRotation(
                      dir,
                      false
                    )}deg)`;
                    cell.appendChild(img);
                  } else {
                    // Fallback if SVG not loaded yet
                    const img = document.createElement("img");
                    img.src = "images/Tunnel.svg";
                    img.alt = "Tunnel";
                    img.style.transform = `rotate(${getRotation(
                      dir,
                      false
                    )}deg)`;
                    cell.appendChild(img);
                  }
                }
              }

              // Add trains and decoys
              const movingObject = activeMovingObjects?.find(
                (o) => o?.row === row + 1 && o?.col === col + 1
              );
              if (movingObject) {
                const rotation = getRotation(movingObject.direction, true);
                const img = document.createElement("img");
                if (movingObject.isDecoy) {
                  img.src = `images/Decoy.svg`;
                  img.alt = `Decoy`;
                } else {
                  const carIndex = (movingObject.idx ?? 0) + 1;
                  img.src = `images/Car ${carIndex}.svg`;
                  img.alt = `Car ${carIndex}`;
                }
                img.style.transform = `rotate(${rotation}deg)`;
                img.style.zIndex = "10";
                cell.appendChild(img);
              }

              // Add gates
              const gateIndex = gates?.findIndex(
                ([r, c]) => r === row + 1 && c === col + 1
              );
              if (gateIndex !== -1) {
                const gate = gates[gateIndex];
                const gate_id = gateIndex + 1;
                const [, , activation_id, initially_open] = gate;
                const gateDiv = document.createElement("div");

                let isOpen = initially_open;
                if (
                  gateOpenStates?.[gateIndex] &&
                  currentTimeStep < gateOpenStates[gateIndex].length
                ) {
                  isOpen = gateOpenStates[gateIndex][currentTimeStep];
                }

                gateDiv.className = `gate-indicator ${
                  isOpen ? "gate-open" : "gate-closed"
                }`;
                gateDiv.textContent = activation_id;
                gateDiv.title = `Gate ${gate_id}: ${
                  isOpen ? "Open" : "Closed"
                }`;
                cell.appendChild(gateDiv);
              }

              // Add activations
              const activation = activations?.find(
                ([r, c]) => r === row + 1 && c === col + 1
              );
              if (activation) {
                const [, , activation_id] = activation;
                const activationDiv = document.createElement("div");
                activationDiv.className = "activation-indicator";
                activationDiv.textContent = activation_id;
                activationDiv.title = `Activation for Gate/DSwitch ${activation_id}`;
                cell.appendChild(activationDiv);
              }

              // Add dswitch indicators
              const dswitch = dswitches?.find(
                ([r, c]) => r === row + 1 && c === col + 1
              );
              if (dswitch) {
                const [, , dswitch_id] = dswitch;
                const dswitchDiv = document.createElement("div");
                dswitchDiv.className = "dswitch-indicator";
                dswitchDiv.textContent = dswitch_id;
                dswitchDiv.title = `DSwitch ${dswitch_id} (toggles on activation)`;
                cell.appendChild(dswitchDiv);
              }

              // Add station indicators
              const station = stations?.find(
                ([r, c]) => r === row + 1 && c === col + 1
              );
              if (station) {
                const [, , train_id] = station;
                const stationDiv = document.createElement("div");
                stationDiv.className = "station-indicator";
                stationDiv.textContent = train_id;
                stationDiv.title = `Station for Train ${train_id} (2-step wait)`;
                cell.appendChild(stationDiv);
              }

              container.appendChild(cell);
            }
          }
        }

        function getPositionsAtTime(timeStep, paths, initialPositions) {
          if (
            typeof timeStep !== "number" ||
            Number.isNaN(timeStep) ||
            timeStep < 0
          ) {
            return initialPositions;
          }

          if (timeStep === 0) {
            return initialPositions;
          }

          const desiredStep = Math.min(
            Math.floor(timeStep),
            maxTimeStep
          );

          if (!Array.isArray(paths) || paths.length === 0) {
            return initialPositions;
          }

          const count = Math.max(
            paths.length,
            initialPositions.length
          );

          const positions = [];

          for (let idx = 0; idx < count; idx++) {
            const path = paths[idx];
            if (Array.isArray(path) && path.length > 0) {
              const stepIndex = Math.min(desiredStep - 1, path.length - 1);
              positions.push(
                path[stepIndex] || initialPositions[idx] || null
              );
            } else if (initialPositions[idx]) {
              positions.push(initialPositions[idx]);
            }
          }

          return positions.filter(Boolean);
        }

        // Wait for tunnel SVG to load before drawing initial grid
        await tunnelSvgPromise;
        drawGrid(null, [...initialTrainPositions, ...initialDecoyPositions]);

        function setSolution(data) {
          if (!data) {
            return;
          }

          currentGridData = safeParseJSON(data?.grid, null);
          shouldToggle = safeParseJSON(data?.should_toggle, []);
          eswitchToggledStates = safeParseJSON(data?.eswitch_toggled, []);

          const rawTrainPaths = safeParseJSON(data?.train_paths, []);
          trainPaths = Array.isArray(rawTrainPaths)
            ? rawTrainPaths.map((path, idx) => {
                if (!Array.isArray(path)) {
                  return [];
                }

                const positions = path
                  .map((step) => {
                    if (!Array.isArray(step)) {
                      return null;
                    }
                    const [row, col] = step;
                    if (
                      typeof row !== "number" ||
                      typeof col !== "number"
                    ) {
                      return null;
                    }
                    return { row, col };
                  })
                  .filter(Boolean);

                const computedSteps = determineStepDirections(
                  positions,
                  initialTrainPositions[idx]?.direction ?? null
                );

                return computedSteps.map((step) => ({
                  ...step,
                  idx,
                  isDecoy: false,
                }));
              })
            : [];

          const rawDecoyPaths = safeParseJSON(data?.decoy_paths, []);
          decoyPaths = Array.isArray(rawDecoyPaths)
            ? rawDecoyPaths.map((path, idx) => {
                if (!Array.isArray(path)) {
                  return [];
                }

                const positions = path
                  .map((step) => {
                    if (!Array.isArray(step)) {
                      return null;
                    }
                    const [row, col] = step;
                    if (
                      typeof row !== "number" ||
                      typeof col !== "number"
                    ) {
                      return null;
                    }
                    return { row, col };
                  })
                  .filter(Boolean);

                const computedSteps = determineStepDirections(
                  positions,
                  initialDecoyPositions[idx]?.direction ?? null
                );

                return computedSteps.map((step) => ({
                  ...step,
                  idx,
                  isDecoy: true,
                }));
              })
            : [];

          const trainPathLengths = rawTrainPaths.map((p) => p.length);
          const decoyPathLengths = rawDecoyPaths.map((p) => p.length);

          const maxTrainTime =
            trainPathLengths.length > 0 ? Math.max(...trainPathLengths) : 0;
          const maxDecoyTime =
            decoyPathLengths.length > 0 ? Math.max(...decoyPathLengths) : 0;

          maxTimeStep = Math.max(maxTrainTime, maxDecoyTime);

          computeGateStates();
          computeDSwitchStates();

          if (maxTimeStep > 0 || initialTrainPositions.length > 0 || initialDecoyPositions.length > 0) {
            timelineControls.style.display = "block";
            timeSlider.min = 0;
            timeSlider.max = maxTimeStep;
            if (!timeSliderInUpdate) {
              currentTimeStep = currentTimeStep
                ? Math.min(currentTimeStep, maxTimeStep)
                : 0;
              timeSlider.value = currentTimeStep;
            }
            timeLabel.textContent = `${currentTimeStep} / ${maxTimeStep}`;
          } else {
            timelineControls.style.display = "none";
            currentTimeStep = 0;
            timeSlider.value = 0;
            timeSlider.min = 0;
            timeSlider.max = 0;
            timeLabel.textContent = "0";
          }

          const trainPositions = getPositionsAtTime(currentTimeStep, trainPaths, initialTrainPositions);
          const decoyPositions = getPositionsAtTime(currentTimeStep, decoyPaths, initialDecoyPositions);
          drawGrid(
            currentGridData,
            [...trainPositions, ...decoyPositions]
          );
        }

        timeSlider.addEventListener("input", (event) => {
          timeSliderInUpdate = true;

          const sliderValue = Number(event.target.value);

          const clampedValue = Math.min(
            Math.max(sliderValue, 0),
            maxTimeStep
          );
          currentTimeStep = clampedValue;
          event.target.value = clampedValue;
          timeLabel.textContent = `${clampedValue} / ${maxTimeStep}`;
          
          const trainPositions = getPositionsAtTime(currentTimeStep, trainPaths, initialTrainPositions);
          const decoyPositions = getPositionsAtTime(currentTimeStep, decoyPaths, initialDecoyPositions);

          drawGrid(
            currentGridData,
            clampedValue === 0
              ? [...initialTrainPositions, ...initialDecoyPositions]
              : [...trainPositions, ...decoyPositions]
          );
          timeSliderInUpdate = false;
        });

        // Visualise last solution on startup
        const numSols = await MiniZincIDE.getNumSolutions();
        if (numSols > 0) {
          const solution = await MiniZincIDE.getSolution(numSols - 1);
          setSolution(solution.data);
        }

        // Show new solutions if we're following the latest solution
        let followLatest = true;
        MiniZincIDE.on("solution", (solution) => {
          if (followLatest) {
            setSolution(solution.data);
          }
        });

        MiniZincIDE.on("goToSolution", async (index) => {
          followLatest = index === -1;
          const solution = await MiniZincIDE.getSolution(index);
          setSolution(solution.data);
        });
      })();
    </script>
  </body>
</html>